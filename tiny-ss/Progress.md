# Spring Security 第一阶段学习进度跟踪

> **学习目标：** 夯实基础 —— 单体应用内的 Spring Security 精通
> **模块：** tiny-ss
> **开始时间：** 2025-11-07

## 📋 总体进度概览

| 步骤 | 功能模块 | 状态 | 完成日期 | 简历亮点 |
|------|----------|------|----------|----------|
| 1 | 动态 RBAC 权限系统 | ⏳ 待开始 | | 实现基于RBAC模型的动态权限管理系统 |
| 2 | "记住我"功能 | ⏳ 待开始 | | 设计并实现安全的"记住我"功能 |
| 3 | CSRF 防护配置 | ⏳ 待开始 | | 深入理解CSRF攻击原理及防御机制 |
| 4 | 方法级权限控制 | ⏳ 待开始 | | 实现URL和方法级别的精细授权 |
| 5 | Session 管理和会话控制 | ⏳ 待开始 | | 会话管理和并发控制 |
| 6 | 密码策略验证 | ⏳ 待开始 | | 密码安全和用户安全增强 |

**当前整体进度：** 0/6 步骤完成

---

## 🎯 步骤一：实现完整的动态 RBAC 权限系统

**状态：** ⏳ 待开始
**预计时间：** 2-3天
**重要性：** ⭐⭐⭐⭐⭐ (企业级核心需求)

### 📚 学习目标
- 理解 RBAC (Role-Based Access Control) 模型
- 掌握动态权限数据库设计
- 实现自定义权限评估器
- 达到权限实时配置的效果

### 🛠️ 实现清单

#### **1. 数据库设计**
- [ ] 创建 `Permission` 实体类（权限表）
- [ ] 创建 `Role` 实体类（角色表）
- [ ] 创建 `UserRole` 实体类（用户-角色关联表）
- [ ] 创建 `RolePermission` 实体类（角色-权限关联表）
- [ ] 设计数据库表结构和关系映射

#### **2. 核心服务实现**
- [ ] 实现 `PermissionService`
- [ ] 实现 `RoleService`
- [ ] 扩展 `UserDetailsServiceImpl` 加载用户权限
- [ ] 实现自定义 `PermissionEvaluator`

#### **3. 安全配置增强**
- [ ] 在 `SecurityConfig` 中启用方法级安全
- [ ] 配置 `@EnableMethodSecurity`
- [ ] 测试不同权限的访问控制

#### **4. 测试验证**
- [ ] 创建测试用的权限标识符（如 `user:create`, `user:read`, `user:update`, `user:delete`）
- [ ] 创建测试角色（如 `USER_MANAGER`, `ORDER_MANAGER`）
- [ ] 测试权限动态分配和即时生效
- [ ] 验证方法级权限注解的生效

### 🧪 测试方案

#### **测试场景 1：基础权限验证**
```java
// 创建不同角色的用户
// 1. ADMIN 用户 - 应该有所有权限
// 2. USER_MANAGER 用户 - 只有用户管理权限
// 3. ORDER_MANAGER 用户 - 只有订单管理权限
// 4. 普通用户 - 只有基础权限

// 测试方法
@GetMapping("/admin/users")
@PreAuthorize("hasPermission('user', 'read')")
public String listUsers() { ... }

@GetMapping("/admin/users/create")
@PreAuthorize("hasPermission('user', 'create')")
public String createUser() { ... }
```

#### **测试场景 2：动态权限分配**
```sql
-- 运行时给角色分配新权限
INSERT INTO role_permission (role_id, permission_id) VALUES (2, 5);

-- 验证权限立即生效，无需重启应用
```

#### **测试场景 3：权限继承**
```java
// 测试角色权限继承关系
// ADMIN 角色应该自动继承所有其他角色的权限
```

### ✅ 验证标准
- [ ] 不同角色用户访问不同页面的权限控制正确
- [ ] 方法级权限注解生效，无权限用户被正确拦截
- [ ] 权限动态分配后立即生效，无需重启
- [ ] 权限数据库设计合理，支持复杂业务场景

### 📝 学习笔记
*(记录遇到的问题、解决方案和心得体会)*

---

## 🎯 步骤二：实现安全的"记住我"功能

**状态：** ⏳ 待开始
**预计时间：** 1-2天
**重要性：** ⭐⭐⭐⭐ (用户体验与安全平衡)

### 📚 学习目标
- 理解 "记住我" 功能的安全原理
- 掌握 Token 持久化方案
- 实现用户主动管理记住我会话
- 平衡用户体验与安全性

### 🛠️ 实现清单

#### **1. 数据库设计**
- [ ] 创建 `persistent_logins` 表结构
- [ ] 设计 Token 存储和管理策略

#### **2. 安全配置**
- [ ] 配置 `JdbcTokenRepositoryImpl`
- [ ] 配置 `RememberMeServices`
- [ ] 设置合理的 Token 有效期
- [ ] 配置 Token 安全参数

#### **3. 前端界面**
- [ ] 在登录页面添加"记住我"复选框
- [ ] 创建用户会话管理页面
- [ ] 实现查看和吊销记住我会话功能

#### **4. 测试验证**
- [ ] 测试记住我功能的正常流程
- [ ] 测试 Token 过期机制
- [ ] 测试用户主动吊销会话
- [ ] 测试安全性（Token 篡改等）

### 🧪 测试方案

#### **测试场景 1：基本功能测试**
```java
// 1. 用户登录时勾选"记住我"
// 2. 关闭浏览器后重新访问
// 3. 验证用户仍保持登录状态
// 4. 检查数据库中的 persistent_logins 记录
```

#### **测试场景 2：安全性测试**
```java
// 1. 篡改 Cookie 中的 remember-me token
// 2. 验证系统正确识别并拒绝非法 token
// 3. 测试 Token 过期后的处理
// 4. 验证修改密码后所有记住 me 会话失效
```

#### **测试场景 3：会话管理测试**
```java
// 1. 用户查看所有活跃的记住 me 会话
// 2. 用户主动吊销某个会话
// 3. 用户一键吊销所有会话
// 4. 验证被吊销的会话立即失效
```

### ✅ 验证标准
- [ ] 记住我功能正常工作，用户体验良好
- [ ] Token 安全存储，防止篡改和窃取
- [ ] 用户可以有效管理自己的记住 me 会话
- [ ] 修改密码后所有相关会话自动失效
- [ ] Token 过期机制正确工作

### 📝 学习笔记

---

## 🎯 步骤三：完善 CSRF 防护配置

**状态：** ⏳ 待开始
**预计时间：** 1天
**重要性：** ⭐⭐⭐⭐ (Web安全必备)

### 📚 学习目标
- 深入理解 CSRF 攻击原理
- 掌握 Spring Security CSRF 防护机制
- 实现前后端分离场景下的 CSRF 保护
- 了解何时以及如何安全地禁用 CSRF

### 🛠️ 实现清单

#### **1. CSRF 配置**
- [ ] 重新启用 CSRF 保护
- [ ] 配置 `CsrfTokenRepository`
- [ ] 设置 CSRF 安全策略
- [ ] 配置例外请求路径

#### **2. 前端集成**
- [ ] 在所有表单中添加 CSRF token
- [ ] 为 AJAX 请求配置 CSRF header
- [ ] 实现动态 CSRF token 刷新
- [ ] 处理 CSRF token 过期情况

#### **3. 测试验证**
- [ ] 测试正常请求的 CSRF 验证
- [ ] 测试 CSRF 攻击防护效果
- [ ] 测试前后端分离场景
- [ ] 验证例外配置的正确性

### 🧪 测试方案

#### **测试场景 1：基本防护验证**
```html
<!-- 测试表单提交是否包含 CSRF token -->
<form action="/user/update" method="post">
    <input type="hidden" name="${_csrf.parameterName}" value="${_csrf.token}"/>
    <!-- 其他表单字段 -->
</form>
```

#### **测试场景 2：AJAX 请求测试**
```javascript
// 测试 AJAX 请求是否正确携带 CSRF token
fetch('/api/user/update', {
    method: 'POST',
    headers: {
        'Content-Type': 'application/json',
        'X-XSRF-TOKEN': getCookie('XSRF-TOKEN')
    },
    body: JSON.stringify(userData)
});
```

#### **测试场景 3：攻击模拟测试**
```html
<!-- 构造跨站请求伪造攻击 -->
<img src="http://localhost:19501/user/delete?id=123" style="display:none"/>
<!-- 验证攻击被成功拦截 -->
```

### ✅ 验证标准
- [ ] 所有表单提交都包含有效的 CSRF token
- [ ] AJAX 请求正确携带 CSRF header
- [ ] CSRF 攻击被成功拦截
- [ ] 例外配置正确工作，不影响必要功能
- [ ] 前后端分离场景下 CSRF 保护正常

### 📝 学习笔记

---

## 🎯 步骤四：实现方法级权限控制

**状态：** ⏳ 待开始
**预计时间：** 1-2天
**重要性：** ⭐⭐⭐ (精细化权限控制)

### 📚 学习目标
- 掌握方法级安全注解的使用
- 理解不同权限注解的区别和应用场景
- 实现复杂业务逻辑的权限控制
- 掌握权限表达式的高级用法

### 🛠️ 实现清单

#### **1. 配置启用**
- [ ] 配置 `@EnableMethodSecurity`
- [ ] 设置 `prePostEnabled = true`
- [ ] 配置 `securedEnabled = true`
- [ ] 配置 `jsr250Enabled = true`

#### **2. 注解应用**
- [ ] 使用 `@PreAuthorize` 实现前置权限检查
- [ ] 使用 `@PostAuthorize` 实现后置权限过滤
- [ ] 使用 `@Secured` 实现角色检查
- [ ] 使用 `@PreFilter` 和 `@PostFilter` 过滤数据

#### **3. 测试验证**
- [ ] 创建测试 Controller 和 Service
- [ ] 测试各种权限注解的效果
- [ ] 测试复杂权限表达式
- [ ] 验证权限检查的性能影响

### 🧪 测试方案

#### **测试场景 1：@PreAuthorize 测试**
```java
@PreAuthorize("hasRole('ADMIN')")
public void adminOnlyMethod() { ... }

@PreAuthorize("hasPermission(#userId, 'user', 'read')")
public User getUserById(Long userId) { ... }

@PreAuthorize("hasAuthority('ORDER_MANAGE') and #order.userId == authentication.principal.id")
public Order updateOrder(Order order) { ... }
```

#### **测试场景 2：@PostAuthorize 测试**
```java
@PostAuthorize("returnObject.owner == authentication.name")
public Document getDocument(Long id) { ... }

@PostAuthorize("filterObject.ownedBy(authentication.name)")
public List<Document> getDocuments() { ... }
```

#### **测试场景 3：数据过滤测试**
```java
@PreFilter("filterObject.owner == authentication.name")
public void processDocuments(List<Document> documents) { ... }

@PostFilter("filterObject.owner == authentication.name")
public List<Document> getAllDocuments() { ... }
```

### ✅ 验证标准
- [ ] 各种权限注解正确工作，无权限访问被拦截
- [ ] 复杂权限表达式正确解析和执行
- [ ] 数据过滤功能正常，只返回用户有权限的数据
- [ ] 权限检查不影响正常业务逻辑执行
- [ ] 性能影响在可接受范围内

### 📝 学习笔记

---

## 🎯 步骤五：增强 Session 管理和会话控制

**状态：** ⏳ 待开始
**预计时间：** 1天
**重要性：** ⭐⭐⭐ (会话安全)

### 📚 学习目标
- 掌握 Session 生命周期管理
- 实现并发会话控制
- 配置会话超时和失效处理
- 理解分布式会话管理

### 🛠️ 实现清单

#### **1. Session 配置**
- [ ] 配置 `SessionManagementFilter`
- [ ] 设置会话超时时间
- [ ] 配置并发会话控制策略
- [ ] 实现会话失效处理

#### **2. 并发控制**
- [ ] 配置最大并发会话数
- [ ] 实现会话注册表
- [ ] 配置会话冲突处理策略
- [ ] 实现强制下线功能

#### **3. 监控和管理**
- [ ] 创建会话监控页面
- [ ] 实现查看用户在线状态
- [ ] 实现管理员强制用户下线
- [ ] 添加会话统计功能

### 🧪 测试方案

#### **测试场景 1：会话超时测试**
```java
// 1. 用户登录后等待会话超时
// 2. 尝试访问需要认证的资源
// 3. 验证被重定向到登录页面
// 4. 检查会话失效日志
```

#### **测试场景 2：并发会话控制测试**
```java
// 1. 在多个浏览器中登录同一账户
// 2. 验证超过最大并发数时的处理
// 3. 测试会话冲突策略（阻止新会话或踢出旧会话）
// 4. 验证会话管理功能
```

#### **测试场景 3：会话管理测试**
```java
// 1. 管理员查看在线用户列表
// 2. 管理员强制指定用户下线
// 3. 用户查看自己的活跃会话
// 4. 用户主动登出其他会话
```

### ✅ 验证标准
- [ ] 会话超时机制正确工作
- [ ] 并发会话控制有效，防止账号滥用
- [ ] 会话管理功能完善，用户体验良好
- [ ] 会话安全配置合理，防止会话固定攻击
- [ ] 管理员可以有效监控和控制用户会话

### 📝 学习笔记

---

## 🎯 步骤六：实现密码策略验证

**状态：** ⏳ 待开始
**预计时间：** 1-2天
**重要性：** ⭐⭐⭐ (用户安全增强)

### 📚 学习目标
- 实现企业级密码策略
- 掌握密码强度验证算法
- 实现密码历史管理
- 提供用户友好的密码规则提示

### 🛠️ 实现清单

#### **1. 密码策略设计**
- [ ] 设计密码策略配置类
- [ ] 实现密码验证规则集合
- [ ] 配置密码策略参数
- [ ] 实现密码策略的动态调整

#### **2. 密码验证器**
- [ ] 实现 `PasswordValidator` 工具类
- [ ] 实现各种密码规则验证方法
- [ ] 实现常见弱密码检查
- [ ] 实现密码与用户名相似性检查

#### **3. 密码历史管理**
- [ ] 创建 `PasswordHistory` 实体
- [ ] 实现密码历史存储和查询
- [ ] 实现密码重复使用检查
- [ ] 配置密码历史保留策略

#### **4. 前端集成**
- [ ] 实现实时密码强度指示器
- [ ] 添加密码规则提示
- [ ] 实现密码确认验证
- [ ] 优化用户输入体验

### 🧪 测试方案

#### **测试场景 1：密码强度验证测试**
```java
// 测试各种密码组合
// 1. 弱密码：123456, password, qwerty
// 2. 中等密码：User123, Test@2023
// 3. 强密码：Tr@v3l!2023#Secur3
// 4. 验证每种情况的验证结果
```

#### **测试场景 2：密码历史测试**
```java
// 1. 用户修改密码
// 2. 尝试使用最近用过的密码
// 3. 验证系统拒绝重复使用
// 4. 测试密码历史保留数量限制
```

#### **测试场景 3：用户体验测试**
```java
// 1. 测试密码强度实时反馈
// 2. 测试密码规则提示的准确性
// 3. 测试密码确认字段的同步验证
// 4. 验证错误提示的友好性
```

### ✅ 验证标准
- [ ] 密码策略配置合理，满足企业安全要求
- [ ] 密码验证算法准确，能有效识别弱密码
- [ ] 密码历史管理正确，防止密码重复使用
- [ ] 前端密码强度指示器工作正常
- [ ] 用户体验良好，密码规则提示清晰

### 📝 学习笔记

---

## 📊 学习总结

### 🎯 核心收获
*(每完成一个步骤后总结核心技能和知识点)*

### 🏆 简历亮点汇总
完成所有步骤后，你将具备以下简历亮点：

1. **精通 Spring Security：** 深入理解其核心过滤器链及认证授权流程，具备实现动态 RBAC 权限、会话管理、CSRF 防护等企业级安全方案的能力。

2. **企业级安全实践：** 实现了基于数据库的动态权限管理系统，支持权限实时配置，通过自定义 `UserDetailsService` 和 `PermissionEvaluator` 将权限数据与业务代码解耦。

3. **用户体验与安全平衡：** 设计并实现了安全的"记住我"功能，采用持久化方案将 Token 存入数据库，支持用户查看和主动吊销所有登录会话。

4. **精细化权限控制：** 掌握了方法级权限控制技术，能够使用 `@PreAuthorize`、`@PostAuthorize` 等注解实现复杂的业务权限逻辑。

5. **会话安全专家：** 具备会话管理、并发控制、会话监控等完整的会话安全解决方案能力。

6. **密码安全专家：** 实现了企业级密码策略，包括密码强度验证、历史管理、用户友好提示等完整的密码安全体系。

### 🚀 后续学习方向
- 第二阶段：微服务架构下的 OAuth2 授权中心
- 第三阶段：OIDC 协议与第三方登录
- 高级主题：安全审计、日志分析、安全监控等

---

## 📅 学习日志

| 日期 | 完成内容 | 遇到的问题 | 解决方案 | 心得体会 |
|------|----------|------------|----------|----------|
|      |          |            |          |          |

---

**最后更新时间：** 2025-11-07
**下次更新计划：** 开始步骤一 - 动态 RBAC 权限系统